From faf9bc011cb452e9def7dcd63dd3a0f6ec823534 Mon Sep 17 00:00:00 2001
From: Antoine Pitrou <antoine@python.org>
Date: Tue, 31 Mar 2020 13:10:16 -0400
Subject: [PATCH] PARQUET-1831: [C++] Fix crashes on invalid input (OSS-Fuzz)

This should fix the following issues:
* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21417
* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21419
* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21420
* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21425
* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21433
* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21453

Closes #6781 from pitrou/PARQUET-1831-oss-fuzz

Authored-by: Antoine Pitrou <antoine@python.org>
Signed-off-by: Benjamin Kietzman <bengilgit@gmail.com>
---
 cpp/src/parquet/arrow/reader_internal.cc | 12 +++++++---
 cpp/src/parquet/column_reader.cc         | 10 +++++++-
 cpp/src/parquet/encoding.cc              | 11 +++++++--
 cpp/src/parquet/metadata.cc              | 30 ++++++++++++++++++++++--
 testing                                  |  2 +-
 5 files changed, 56 insertions(+), 9 deletions(-)

diff --git a/cpp/src/parquet/arrow/reader_internal.cc b/cpp/src/parquet/arrow/reader_internal.cc
index e09df37eeb..25c7dadd12 100644
--- a/cpp/src/parquet/arrow/reader_internal.cc
+++ b/cpp/src/parquet/arrow/reader_internal.cc
@@ -1060,6 +1060,9 @@ Status ConvertToDecimal128<FLBAType>(const Array& array,
   const int32_t byte_width =
       static_cast<const ::arrow::FixedSizeBinaryType&>(*fixed_size_binary_array.type())
           .byte_width();
+  if (byte_width < kMinDecimalBytes || byte_width > kMaxDecimalBytes) {
+    return Status::Invalid("Invalid FIXED_LEN_BYTE_ARRAY length for Decimal128");
+  }
 
   // allocate memory for the decimal array
   std::shared_ptr<Buffer> data;
@@ -1111,8 +1114,8 @@ Status ConvertToDecimal128<ByteArrayType>(const Array& array,
     int32_t record_len = 0;
     const uint8_t* record_loc = binary_array.GetValue(i, &record_len);
 
-    if ((record_len < 0) || (record_len > type_length)) {
-      return Status::Invalid("Invalid BYTE_ARRAY size");
+    if (record_len < 0 || record_len > type_length) {
+      return Status::Invalid("Invalid BYTE_ARRAY length for Decimal128");
     }
 
     auto out_ptr_view = reinterpret_cast<uint64_t*>(out_ptr);
@@ -1121,7 +1124,10 @@ Status ConvertToDecimal128<ByteArrayType>(const Array& array,
 
     // only convert rows that are not null if there are nulls, or
     // all rows, if there are not
-    if (((null_count > 0) && !binary_array.IsNull(i)) || (null_count <= 0)) {
+    if ((null_count > 0 && !binary_array.IsNull(i)) || null_count <= 0) {
+      if (record_len <= 0) {
+        return Status::Invalid("Invalid BYTE_ARRAY length for Decimal128");
+      }
       RawBytesToDecimalBytes(record_loc, record_len, out_ptr);
     }
   }
diff --git a/cpp/src/parquet/column_reader.cc b/cpp/src/parquet/column_reader.cc
index 3cb78e524e..e4dc8dc612 100644
--- a/cpp/src/parquet/column_reader.cc
+++ b/cpp/src/parquet/column_reader.cc
@@ -632,6 +632,14 @@ class ColumnReaderImplBase {
     num_decoded_values_ = 0;
     const uint8_t* buffer = page.data();
 
+    const int64_t total_levels_length =
+        static_cast<int64_t>(page.repetition_levels_byte_length()) +
+        page.definition_levels_byte_length();
+
+    if (total_levels_length > page.size()) {
+      throw ParquetException("Data page too small for levels (corrupt header?)");
+    }
+
     if (max_rep_level_ > 0) {
       repetition_level_decoder_.SetDataV2(page.repetition_levels_byte_length(),
                                           max_rep_level_,
@@ -645,7 +653,7 @@ class ColumnReaderImplBase {
                                           static_cast<int>(num_buffered_values_), buffer);
     }
 
-    return page.repetition_levels_byte_length() + page.definition_levels_byte_length();
+    return total_levels_length;
   }
 
   // Get a decoder object for this page or create a new decoder if this is the
diff --git a/cpp/src/parquet/encoding.cc b/cpp/src/parquet/encoding.cc
index fe2545b76b..d3e5b3ca80 100644
--- a/cpp/src/parquet/encoding.cc
+++ b/cpp/src/parquet/encoding.cc
@@ -1078,7 +1078,7 @@ static inline int64_t ReadByteArray(const uint8_t* data, int64_t data_size,
   if (len < 0) {
     throw ParquetException("Invalid BYTE_ARRAY value");
   }
-  const int64_t consumed_length = static_cast<int64_t>(4 + len);
+  const int64_t consumed_length = static_cast<int64_t>(len) + 4;
   if (ARROW_PREDICT_FALSE(data_size < consumed_length)) {
     ParquetException::EofException();
   }
@@ -1480,7 +1480,11 @@ class DictDecoderImpl : public DecoderImpl, virtual public DictDecoder<Type> {
 
   void SetData(int num_values, const uint8_t* data, int len) override {
     num_values_ = num_values;
-    if (len == 0) return;
+    if (len == 0) {
+      // Initialize dummy decoder to avoid crashes later on
+      idx_decoder_ = arrow::util::RleDecoder(data, len, /*bit_width=*/1);
+      return;
+    }
     uint8_t bit_width = *data;
     if (ARROW_PREDICT_FALSE(bit_width >= 64)) {
       throw ParquetException("Invalid or corrupted bit_width");
@@ -2331,6 +2335,9 @@ template <typename DType>
 void ByteStreamSplitDecoder<DType>::SetData(int num_values, const uint8_t* data,
                                             int len) {
   DecoderImpl::SetData(num_values, data, len);
+  if (num_values * static_cast<int64_t>(sizeof(T)) > len) {
+    throw ParquetException("Data size too small for number of values (corrupted file?)");
+  }
   num_values_in_buffer_ = num_values;
 }
 
diff --git a/cpp/src/parquet/metadata.cc b/cpp/src/parquet/metadata.cc
index 611628a89a..8f424aa68c 100644
--- a/cpp/src/parquet/metadata.cc
+++ b/cpp/src/parquet/metadata.cc
@@ -38,13 +38,39 @@
 #if defined(PARQUET_USE_BOOST_REGEX)
 #include <boost/regex.hpp>  // IWYU pragma: keep
 using ::boost::regex;
-using ::boost::regex_match;
 using ::boost::smatch;
+
+template <typename... Args>
+static bool regex_match(Args&&... args) {
+  try {
+    return boost::regex_match(std::forward<Args>(args)...);
+  } catch (const boost::regex_error& e) {
+    if (e.code() == boost::regex_constants::error_complexity ||
+        e.code() == boost::regex_constants::error_stack) {
+      // Input-dependent error => return as if matching failed
+      return false;
+    }
+    throw;
+  }
+}
 #else
 #include <regex>
 using ::std::regex;
-using ::std::regex_match;
 using ::std::smatch;
+
+template <typename... Args>
+static bool regex_match(Args&&... args) {
+  try {
+    return std::regex_match(std::forward<Args>(args)...);
+  } catch (const std::regex_error& e) {
+    if (e.code() == std::regex_constants::error_complexity ||
+        e.code() == std::regex_constants::error_stack) {
+      // Input-dependent error => return as if matching failed
+      return false;
+    }
+    throw;
+  }
+}
 #endif
 
 namespace parquet {
diff --git a/testing b/testing
index b46e3a709c..84730c2fa8 160000
--- a/testing
+++ b/testing
@@ -1 +1 @@
-Subproject commit b46e3a709c948ef77584635098e5f921fe05700c
+Subproject commit 84730c2fa8f3f7d0ecd79b05b38446375972ef4f
-- 
2.49.0

