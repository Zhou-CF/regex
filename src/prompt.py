GET_REGEX_PY = """
    根据下述的漏洞成因以及补丁信息，写一个python文件，输入是一个文件路径，先读取该路径读取文件，然后通过正则表达式来匹配该漏洞位置。
    请注意：
    1. 正则表达式针对漏洞成因的特定模式进行匹配，尽量精确。
    2. 该python代码的输入会是一个文件路径。通过sys.argv来获取该参数
    3. 读取文件采用utf-8编码
    4. 该python代码的输出是检测到的所有漏洞
    5. 该python代码的输出会是一个json，格式如下：
    {{
      "loc": "<漏洞行号>",
      "reason": "<漏洞成因>",
    }}
    漏洞成因：
    <成因>"
    {cve_content}
    </成因>

    <补丁信息>
    {patch_content}
    </补丁信息>
"""

FIX_REGEX_PY = """
    现在已有一个python代码，该代码是基于正则来查询项目中漏洞位置的脚本，但是这个正则能匹配到的内容过多，导致误报率很高。
    请根据下述的漏洞成因以及补丁信息，修改该python代码中的正则表达式，使得该正则表达式能更精确的匹配漏洞位置。
    请注意：
    1. 正则表达式针对漏洞成因的特定模式进行匹配，尽量精确。
    2. 该python代码的输入会是一个文件路径。通过sys.argv来获取该参数
    3. 读取文件采用utf-8编码
    4. 该python代码的输出是检测到的所有漏洞
    5. 该python代码的输出会是一个json，格式如下：
    {{
      "loc": "<漏洞行号>",
      "reason": "<漏洞成因>",
    }}
    请修改python代码中的正则表达式部分，确保它能更精确地匹配漏洞位置。
    <python代码>
    {code}
    </python代码>
    
    漏洞成因：
    <成因>"
    {cve_content}
    </成因>

    <补丁信息>
    {patch_content}
    </补丁信息>
"""

FIND_TRUE_RES = """
    根据提供的代码片段以及补丁信息，判断该代码片段是否与补丁修复的内容相关。
    请注意：
    1. 先根据补丁简单分析漏洞成因
    2. 然后判断代码片段是否与漏洞成因相关
    3. 如果代码片段展示的内容的与漏洞成因的内容以及补丁的内容相关，返回True，否则返回False。
      1. 如代码片段展示的函数与补丁修复的函数一致，则意味着代码片段与该补丁修复相关。则返回True
    <代码片段>
    {code}
    </代码片段>
    <补丁信息>
    {patch_content}
    </补丁信息>

    返回以json格式返回：
    {{
      "reason": "<原因>",
      "result": <True或False>
    }}
    """

ONLY_PATCH_PY =  """
    根据下述的补丁信息,先分析漏洞成因，然后写一个python文件，输入是一个文件路径，先读取该路径读取文件，然后通过正则表达式来匹配该漏洞位置。
    请注意：
    1. 正则表达式针对漏洞成因的特定模式进行匹配，尽量精确。
    2. 该python代码的输入会是一个文件路径。通过sys.argv来获取该参数
    3. 读取文件采用utf-8编码
    4. 读取文件失败则返回的行号为0
    5. 该python代码的输出是检测到的所有漏洞
    6. 该python代码的输出会是一个json，格式如下：
    [{{
      "loc": "<漏洞行号>",
      "reason": "<漏洞成因>",
    }}]

    <补丁信息>
    {patch_content}
    </补丁信息>
"""

FIX_REGEX_ONLYPATCH_PY = """
    现在已有一个python代码，该代码是基于正则来查询项目中漏洞位置的脚本，但是这个正则能匹配到的内容过多，导致误报率很高。
    请根据下述的漏洞成因以及补丁信息，修改该python代码中的正则表达式，使得该正则表达式能更精确的匹配到修复前的代码，而匹配不到修复后的代码。
    请注意：
    1. 正则表达式针对漏洞成因的特定模式进行匹配，尽量精确。
    2. 该python代码的输入会是一个文件路径。通过sys.argv来获取该参数
    3. 读取文件采用utf-8编码
    4. 该python代码的输出是检测到的所有漏洞
    5. 该python代码的输出会是一个json，格式如下：
    {{
      "loc": "<漏洞行号>",
      "reason": "<漏洞成因>",
    }}
    请修改python代码中的正则表达式部分，确保它能更精确地匹配漏洞位置。
    <python代码>
    {code}
    </python代码>

    <补丁信息>
    {patch_content}
    </补丁信息>
"""

FIX_ERR_REGEX_ONLYPATCH_PY = """
    现在已有一个python代码，该代码是基于正则来查询项目中漏洞位置的脚本，但是这个正则匹配不到漏洞。
    请根据下述的漏洞成因以及补丁信息，修改该python代码中的正则表达式，使得该正则表达式能更精确的匹配到修复前的代码，而匹配不到修复后的代码。
    请注意：
    1. 正则表达式针对漏洞成因的特定模式进行匹配，尽量精确。
    2. 该python代码的输入会是一个文件路径。通过sys.argv来获取该参数
    3. 读取文件采用utf-8编码
    4. 该python代码的输出是检测到的所有漏洞
    5. 该python代码的输出会是一个json，格式如下：
    {{
      "loc": "<漏洞行号>",
      "reason": "<漏洞成因>",
    }}
    请修改python代码中的正则表达式部分，确保它能更精确地匹配漏洞位置。
    <python代码>
    {code}
    </python代码>

    <补丁信息>
    {patch_content}
    </补丁信息>
"""